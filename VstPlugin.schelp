TITLE:: VstPlugin
summary:: load VST plugins and use them as Synths
categories:: Server>Nodes, Server>Abstractions
related:: Classes/Synth, Classes/Node, Classes/SynthDef

DESCRIPTION::

With VstPlugin you can load VST plugins on all platforms and use them to generate or process sounds on an audio bus.
The class is derived from link::Classes/Synth:: and can be created and used similarly except you don't have to provide a SynthDef name.

warning::Please read the sections about link::#Realtime-Safety:: and link::#Other Caveats:: ::

A VstPlugin instance processes audio by reading from an audio bus, sending the content to the VST plugin and writing the new signal either to the same or another audio bus.
You can specify whether you want to sum into the bus or rather replace its content (see link::#Serial VS Parallel::). 

You can create VstPlugin instances via the class method code::new:::
code::
// create a VstPlugin with 2 input channels and 2 output channels which reads from Bus 3 and writes to Bus 0, not bypassed and not replacing:
f = VstPlugin.new([\nin, 2, \nout, 2, \in, 3, \out, 0, \bypass, 0, \replace, 0], s, addAction: \addToHead);

// most arguments have default values so you can achieve the same result with:
f = VstPlugin.new([\in, 3, \out, 0]);
::
All arguments except code::\nin:: and code::\nout:: can be changed later with code::set::, code::map::, etc. See the link::Classes/Node:: helpfile.
code::
f.set(\bypass, 1); // bypass
::
Here's how to actually open a VST plugin:
code::
// watch the console for information or error messages
f.open("/path/to/plugin", info: true);
// open the GUI window:
f.showGui; 
::
If no plugin is loaded, audio is passed through unchanged, just like setting code::\bypass:: to 1.

subsection:: Serial VS Parallel

With emphasis::serial processing::, plugins would typically read and write on the same bus (replacing the old output with the new one) while with emphasis::parallel processing::, plugins read from (possibly different) input busses and sum into a common output bus.

The code::\replace:: argument specifies whether the old content in the output bus should be replaced or not. A non-zero value means replacing (like link::Classes/ReplaceOut::), zero means summing (like link::Classes/Out::). As a rule of thumb, you would often use replacing with serial processing and non-replacing (summing) with parallel processing.

Since a single instance of VstPlugin represents a link::Classes/Node:: on the link::Classes/Server::, you can freely interconnect several VST plugins and form complex serial and/or parallel FX chains just like in a DAW like REAPER.

Here's a complete example for a simple serial FX chain:
code::
(

// load a sound buffer as the test signal:
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// create a 2-channel audio FX bus:
c = Bus.audio(s, 2);

// play the soundfile and route it to the FX bus:
d = SynthDef(\testSignal, {| out = 0, bufnum = 0 |
    Out.ar(out,
        PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), loop: 1, doneAction: Done.freeSelf).dup * 0.5
    )
}).play(s, [\out, c, \bufnum, b]);

// route the FX bus to your audio output to hear the unmodified test signal:
e = SynthDef(\testOut, {| in = 0, out = 0 |
	Out.ar(out, In.ar(in, 2))
}).play(d, [\in, c, \out, 0], addAction: \addAfter);

)

// insert a plugin (adding it *after* d but *before* e):
f = VstPlugin.new([\in, c, \out, c, \replace, 1], d, addAction: \addAfter);
// actually open the plugin (watch the console for errors)
f.open("/path/to/first/plugin", info: true);
f.showGui; // this should open a window with a simple GUI - try it out!

// insert another plugin (after the first one):
g = VstPlugin.new([\in, c, \out, c, \replace, 1], d, addAction: \addAfter);
g.open("/path/to/second/plugin", info: true);
g.showGui;

f.set(\bypass, 1); // bypass first plugin
g.set(\bypass, 1); // bypass second plugin

::

subsection:: Parameter Automation and Preset Management

It is possible to automate plugin parameters programmatically:

code::
// set a single parameter value (always normalized to the range 0.0 - 1.0):
f.setParameter(0, 0.3);

// map a parameter to a control bus:
u = Bus.control(s, 1);
f.mapParameter(1, u);
u.set(0.7);
::

You can read/write preset files to set all parameters at once:
code::
// write current plugin state to a preset file. You can actually choose any extension but .fxp is quite common and will be recognized by most DAWs.
f.writeProgram("/preset/file/path/test.fxp");

// ... mess around with the plugin ...
f.showGui;

// restore previous state:
f.readProgram("/preset/file/path/text.fxp");
::

It's also possible to get/set the raw plugin state as an link::Classes/Int8Array:: if you want to build your own preset management:
code::
// get plugin state as Int8Array:
f.getProgramData({ arg data; d = data;});

// ... mess around with the plugin ...
f.showGui;

// restore previous state:
f.setProgramData(d);
::

subsection:: GUI

The code::gui:: argument to the code::open:: method specifies the type of GUI to instantiate: 

code::
f.open("/path/to/plugin", gui: \vst);
::

The default value code::\sc:: creates a generic Qt GUI in the Language which communicates with the Server via OSC messages.

On Windows and Linux you can choose code::\vst:: instead to get a native window on the server containing the 'real' VST plugin editor.
note:: Unfortunately, this is not possible (yet) on macOS for technical reasons.::

Use code::\none:: if you don't need any GUI to save some ressources.

subsection:: Realtime-Safety

The following operations are not realtime-safe (don't execute within some guaranteed time) for various technical reasons:
list::
## opening/closing a plugin
## reading/writing program/bank files
::
and to a lesser extend:
list::
## setting/getting program/dank data
## sending/receiving sysex data
::

You are adviced to open your plugins in advance to avoid audio glitches during a performance. Unlike other type of Synths, VstPlugin is not meant to be created/destroyed on the fly.

subsection:: Other Caveats

Whenever you open a VST plugin, the server sends all relevant information (e.g. parameter and program names) as OSC messages to the VstPlugin instance.

In case of plugins with emphasis::lots:: of parameters or when loading many plugins at once you might experience dropped OSC messages when using UDP.
You can try to add some delay between loading plugins or switch to TCP to mitigate this problem.

CLASSMETHODS::

METHOD:: new
Create a new VstPlugin instance, similar to link::Classes/Synth#*new::

ARGUMENT:: args
An optional Array specifying initial values for the SynthDef's arguments.
The following arguments are possible:
definitionlist::
## \nin || number of input channels (cannot be changed later)
## \nout || number of output channels (cannot be changed later)
## \in || input bus number
## \out || output bus number (may be the same as the input bus)
## \bypass || 1: true, 0: false
## \replace || 1: true, 0: false (see link::#Serial VS Parallel::)
::

ARGUMENT:: target
the target

ARGUMENT:: addAction
the add action

METHOD:: newPaused
See link::Classes/Synth#*newPaused::

METHOD:: after
See link::Classes/Synth#*after::

METHOD:: before
See link::Classes/Synth#*before::

METHOD:: head
See link::Classes/Synth#*head::

METHOD:: tail
See link::Classes/Synth#*tail::

METHOD:: replace
See link::Classes/Synth#*replace::

PRIVATE:: msg2string

INSTANCEMETHODS::

PRIVATE:: prFree, prClear, init, sendMsg, prClearGui, prMidiMsg

METHOD:: open
open a VST plugin.

ARGUMENT:: path
path to the plugin (with or without extension).

ARGUMENT:: onSuccess
a function to be called if the plugin could be loaded successfully.

ARGUMENT:: onFail
a function to be called if the plugin could not be loaded.

ARGUMENT:: gui
the type of GUI to use.
definitionlist::
## \sc || (the default) create a generic Qt GUI in the Language.
## \vst || create a native window with the original VST editor on the Server. note::This doesn't work (yet) on macOS!::
## \none || use no GUI at all.
::

ARGUMENT:: paramDisplay
send string representations of the plugin parameters whenever they are set with code::setParameter::. Disable this to reduce OSC traffic.

ARGUMENT:: info
print plugin info to the console after being loaded successfully.

METHOD:: close
close the current plugin (but don't free the Synth!). You can open another plugin later.

METHOD:: reset
reset the plugin. (E.g. this might clear the delay lines in a reverb plugin.)

METHOD:: free
see link::Classes/Synth#-free::. Will automatically close the plugin.

METHOD:: showGui
shows/hides the GUI window.

subsection:: Plugin Info

METHOD:: info
print plugin info to the console.

METHOD:: loaded
returns:: if a plugin is currently loaded.

METHOD:: name
returns:: the name of the plugin.

METHOD:: numInputs
returns:: the number of input channels (doesn't have to match the actual number of inputs of VstPlugin).

METHOD:: numOutputs
returns:: the number of output channels (doesn't have to match the actual number of outputs of VstPlugin).

METHOD:: hasEditor
returns:: whether the plugin has an editor.

METHOD:: singlePrecision
returns:: whether the plugin supports single precision.

METHOD:: doublePrecision
returns:: whether the plugin supports double precision (only for information, currently we only support single precision processing).

METHOD:: isSynth
returns:: whether the plugin is a soft synth.

subsection:: Parameters

METHOD:: numParameters
returns:: the number of parameters.

METHOD:: parameterNames
returns:: the parameter names as an Array of Strings.

METHOD:: parameterLabels
returns:: the parameter labels (units of measurement) as an Array of Strings.

METHOD:: setParameter
set the value of a plugin parameter. The value is always normalized to the range 0.0 - 1.0. 

If the parameter has been mapped to a control bus, it will be automatically unmapped.

METHOD:: mapParameter
map a parameter to a control bus.

METHOD:: unmapParameter
unmap a parameter from a control bus.

subsection:: Preset Management

METHOD:: numPrograms
returns:: the number of available plugin programs.

METHOD:: programs
returns:: the available programs as an Array of Strings.

METHOD:: currentProgram
returns:: the index of the currently active program.

METHOD:: setProgram
change the program by index.

METHOD:: setProgramName
change the name of the current program.

METHOD:: readProgram
read a program file (usually .FXP).

METHOD:: writeProgram
write a program file (usually .FXP).

METHOD:: setProgramData
set the current program state as an link::Classes/Int8Array::.

METHOD:: getProgramData
get the current program state as an link::Classes/Int8Array::.

ARGUMENT:: action
will be called with the data as the first argument.

METHOD:: readBank
read a bank file (usually .FXB).

METHOD:: writeBank
write a bank file (usually .FXB).

METHOD:: setBankData
set the current bank state as an link::Classes/Int8Array::.

METHOD:: getBankData
get the current bank state as an link::Classes/Int8Array::.

ARGUMENT:: action
will be called with the data as the first argument.

subsection:: MIDI

METHOD:: midiInput
returns:: whether the plugin receives MIDI messages.

METHOD:: midiOutput
returns:: whether the plugin sends MIDI messages.

METHOD:: midiNoteOn
send a MIDI note on message.

METHOD:: midiNoteOff
send a MIDI note off message.

METHOD:: midiControl
send a MIDI CC message.

METHOD:: midiBend
send a MIDI pitch bend message. code::val:: must be in the range 0 - 16383.

METHOD:: midiPolyTouch
send a polyphonic aftertouch message.

METHOD:: midiTouch
send a MIDI channel aftertouch message.

METHOD:: midiProgram
send a MIDI program change message.

METHOD:: midiMsg
send a raw MIDI message with 2-3 bytes (status, data1, data2).

METHOD:: midiSysex
send a system exclusive message as an link::Classes/Int8Array::.

subsection:: Transport

METHOD:: setPlaying
set the transport playing state to true or false. Only necessary for VST plugins which do some kind of sequencing.

METHOD:: setTempo
set the tempo in BPM (beats per minute).

METHOD:: setTimeSignature
set the time signature, e.g. 3/4 -> num = 3, denom = 4.

METHOD:: setTransportPos
set the current transport position (in quarter notes).

METHOD:: getTransportPos
get the current transport position (in quarter notes).

ARGUMENT:: action
a function to be called with the transport position.

TITLE:: VstPlugin
summary:: load VST plugins on all platforms
related:: Classes/VstPluginController
categories:: UGens

DESCRIPTION::
This UGen represents a single VST plugin instance on the Server. See the helpfile of link::Classes/VstPluginController:: for how to control it from the SuperCollider Language.


CLASSMETHODS::

PRIVATE:: kr, init

METHOD:: ar

ARGUMENT:: input
An Array of channels or single input for the plugin to process. You cannot change the size of this once a SynthDef has been built.
Set this to code::nil:: if the plugin takes no audio input (e.g. software synthesizers).

ARGUMENT:: numOut
The number of output channels. This must be a fixed number greater than 0.

ARGUMENT:: bypass
If this is a non-zero value, the inputs are copied to the outputs, thus bypassing the plugin. This can be automated.

ARGUMENT:: params
An optional Array of parameter controls in pairs of index and value. Both can values be automated.
code::
/* 'p1' controls the plugin parameter 1. 'p2' controls a parameter whose index can be set dynamically with 'idx'. */
SynthDef(\test, { arg in, p1, p2, idx;
	var sig = VstPlugin.ar(In.ar(in, 2), 1, 
		params: [1, p1, idx, p2]);
	Out.ar(0, sig);
});
::
You can set the index to a negative value to "unmap" the parameter.
note::Parameters which are controlled in this way can't be automated from the GUI or set via link::Classes/VstPluginController#-set::.
On the other hand, this has no effect if the parameter is already mapped to a control bus via link::Classes/VstPluginController#-map::.
::
ARGUMENT:: id
An optional number or symbol which uniquely identifies the UGen within a SynthDef, so it can be found by link::Classes/VstPluginController::.
This is only necessary if there is more than one VstPlugin instance in the SynthDef:
code::
// an EQ and Chorus in parallel:
SynthDef(\test, { arg in, out;
	var sig;
	sig = VstPlugin.ar(In.ar(in1, 2), 2, id: \eq);
	sig = VstPlugin.ar(sig, 2, id: \chorus);
	Out.ar(out, sig);
}).add;

~synth = Synth(\test, [\in, ~in, \out, ~out]); 
// this is how you get a handle to a specific plugin instance in the Synth:
~eq = VstPluginController.new(~synth, \eq);
~chorus = VstPluginController.new(~synth, \chorus);
// load plugins, etc:
~eq.open("...");
~chorus.open("...");
::

INSTANCEMETHODS::

METHOD:: id
the ID which uniquely identifies the plugin in a SynthDef (can be code::nil::).
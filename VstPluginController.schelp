TITLE:: VstPluginController
summary:: control a VST plugin
categories:: Utility
related:: Classes/VstPlugin

DESCRIPTION::

Together with link::Classes/VstPlugin:: you can load VST plugins on all platforms and use them inside your SynthDefs.

warning::Please read the sections about link::#Realtime-Safety:: and link::#Other Caveats:: ::

Here's a short example for a simple insert effect on a 2-channel audio bus:

code::
SynthDef(\insert, { arg bus;
    ReplaceOut.ar(bus, VstPlugin.ar(In.ar(bus, 2), 2));  
}).add;

// create the synth:
~synth = Synth(\insert, [\bus, ~bus]);
// get a handle to the VstPlugin:
~fx = VstPluginController(~synth);
// open a plugin:
~fx.open("/path/to/plugin", info: true);
// show the GUI:
~fx.showGui;
// etc.
::

If you have more than one instance of VstPlugin in your SynthDef, you need to give them unique IDs so that VstPluginController can find the right instance:

code::
// two VST plugins in series:
SynthDef(\insert2, { arg bus;
    var sig;
	sig = In.ar(bus, 2);
    sig = VstPlugin.ar(sig, 2, id: \eq);
    sig = VstPlugin.ar(sig, 2, id: \chorus);
    ReplaceOut.ar(bus, );  
}).add;

// create the synth:
~synth = Synth(\insert2, [\bus, ~bus]);
// get handles to the VstPlugins:
~eq = VstPluginController(~synth, \eq);
~chorus = VstPluginController(~synth, \chorus);
// etc.
::

subsection:: Parameter Automation and Preset Management

It is possible to automate plugin parameters with UGens or Synth controls, see the code::params:: argument in link::Classes/VstPlugin#*ar::.

Additionally, there are ways to directly set/map parameters with VstPluginController:

code::
// set parameter 3 to value 0.5:
~fx.set(3, 0.5);
// set 3 parameters starting from index, 1:
~fx.setn(1, [0.1, 0.2, 0.3]);

// map a parameter to a control bus:
~ctl = Bus.control(s, 1);
~fx.map(1, ~ctl);
~ctl.set(0.7);
::

It is possible to get the current parameter state:
code::
// get the current value of parameter 3 and post it to the console:
~.fx.get(3, {arg f; f.postln;});
::

You can read/write preset files to save/recall VST programs and banks:
code::
// write current plugin state to a preset file. You can actually choose any extension but .fxp is quite common and will be recognized by most DAWs.
~fx.writeProgram("/preset/file/path/test.fxp");

// ... mess around with the plugin ...
~fx.showGui;

// restore previous state:
~fx.readProgram("/preset/file/path/text.fxp");
::

It's also possible to get/set the raw plugin state link::Classes/Int8Array:: if you want to build your own preset management:
code::
// get plugin state as Int8Array:
~fx.getProgramData({ arg data; d = data;});

// ... mess around with the plugin ...
~fx.showGui;

// restore previous state:
~fx.setProgramData(d);
::

subsection:: GUI

The code::gui:: argument to the code::open:: method specifies the type of GUI to instantiate: 

code::
f.open("/path/to/plugin", gui: \vst);
::

The default value code::\sc:: creates a generic Qt GUI in the Language which communicates with the Server via OSC messages.

On Windows and Linux you can choose code::\vst:: instead to get a native window on the server containing the 'real' VST plugin editor.
note:: Unfortunately, this is not possible (yet) on macOS for technical reasons.::

Use code::\none:: if you don't need any GUI to save some ressources.

subsection:: Realtime-Safety

The following operations are not realtime-safe (yet):
list::
## opening/closing a plugin
## reading/writing program/bank files
::
and to a lesser extend:
list::
## setting/getting program/bank data
## sending/receiving sysex data
::

You are adviced to open your plugins in advance to avoid possible audio glitches.

subsection:: Other Caveats

Whenever you open a VST plugin, the server sends all relevant information (e.g. parameter and program names) as OSC messages to the VstPlugin instance.

In case of plugins with emphasis::lots:: of parameters or when loading many plugins at once you might experience dropped OSC messages when using UDP.
You can try to add some delay between loading plugins or switch to TCP to mitigate this problem.

CLASSMETHODS::

METHOD:: new
Create a new VstPluginController.

ARGUMENT:: synth
the synth

ARGUMENT:: id
the target

ARGUMENT:: synthDef
the synthDef

PRIVATE:: msg2string

INSTANCEMETHODS::

PRIVATE:: prFree, prClear, init, sendMsg, prClearGui, prMidiMsg

METHOD:: open
open a VST plugin.

ARGUMENT:: path
path to the plugin (with or without extension).

ARGUMENT:: onSuccess
a function to be called if the plugin could be loaded successfully.

ARGUMENT:: onFail
a function to be called if the plugin could not be loaded.

ARGUMENT:: gui
the type of GUI to use.
definitionlist::
## \sc || (the default) create a generic Qt GUI in the Language.
## \vst || create a native window with the original VST editor on the Server. note::This doesn't work (yet) on macOS!::
## \none || use no GUI at all.
::

ARGUMENT:: paramDisplay
send string representations of the plugin parameters whenever they are set with code::setParameter::. Disable this to reduce OSC traffic.

ARGUMENT:: info
print plugin info to the console after being loaded successfully.

METHOD:: close
close the current plugin (but don't free the Synth!). You can open another plugin later.

METHOD:: reset
reset the plugin. (E.g. this might clear the delay lines in a reverb plugin.)

METHOD:: showGui
shows/hides the GUI window.

METHOD:: synth
returns:: the link::Classes/Synth:: of the currently controlled link::Classes/VstPlugin:: instance.

METHOD:: synthIndex
returns:: the index of the link::Classes/VstPlugin:: instance within the link::Classes/Synth::.

subsection:: Plugin Info

METHOD:: info
print plugin info to the console.

METHOD:: loaded
returns:: if a plugin is currently loaded.

METHOD:: name
returns:: the name of the plugin.

METHOD:: numInputs
returns:: the number of input channels (doesn't have to match the actual number of inputs of VstPlugin).

METHOD:: numOutputs
returns:: the number of output channels (doesn't have to match the actual number of outputs of VstPlugin).

METHOD:: hasEditor
returns:: whether the plugin has an editor.

METHOD:: singlePrecision
returns:: whether the plugin supports single precision.

METHOD:: doublePrecision
returns:: whether the plugin supports double precision (only for information, currently we only support single precision processing).

METHOD:: isSynth
returns:: whether the plugin is a soft synth.

subsection:: Parameters

METHOD:: numParameters
returns:: the number of parameters.

METHOD:: parameterNames
returns:: the parameter names as an Array of Strings.

METHOD:: parameterLabels
returns:: the parameter labels (units of measurement) as an Array of Strings.

METHOD:: set
Set plugin parameters.

discussion::
This method expects pairs of parameter index and value. The value(s) should be in the range 0.0 - 1.0.
code::
// set parameter 3 to value 0.9:
~fx.set(3, 0.9);
// set parameters 1 and 5:
~fx.set(1, 0.5, 5, 0.75);
::
If the parameter has been mapped to a control bus, it will be automatically unmapped.

METHOD:: setn
set sequential ranges of parameters.

discussion::
This method expects pairs of parameter index and Array of values.

code::
// this will set parameters 3, 4, 8, 9 and 10.
~fx.setn(3, [0.5, 0.75], 8, [0.1, 0.2, 0.3]);
::

METHOD:: map
map parameters to control busses.

discussion::
This methods expects pairs of parameter index and bus.
In case of multi-channel control busses the channels are mapped to a sequential range of parameters starting at the given index.
code::
~bus1 = Bus.control;
~bus2 = Bus.control(numChannels: 2);
~fx.map(3, ~bus1, 5, ~bus2);
~bus1.set(0.5); // set parameter 3
~bus2.set(0.75, 0.9); // set parameters 5 and 6.
::
note::Mapping parameters to control busses overrides any automation via UGens in the SynthDef.
::

METHOD:: unmap
Unmap parameters from a control bus.

discussion::
Pass all the parameters you want to unmap. Calling the method without arguments will unmap all parameters.
code::
// unmap parameters 4, 5, and 7
~fx.unmap(4, 5, 7);
::

METHOD:: get
get the current value of a plugin parameter.

ARGUMENT:: index
the index of the parameter.

ARGUMENT:: action
a Function which will be evaluated with the value passed as an argument.

discussion::
code::
// get the value of parameter 4 and post it to the console:
~fx.get(4, {arg f: f.postln;});
::

METHOD:: getn
get a sequential range of parameter values.

ARGUMENT:: index
the starting index.

ARGUMENT:: count
the number of sequential parameter values. If it is code::nil::, you'll get all parameters starting from emphasis::index:: up to the last parameter.

ARGUMENT:: action
a Function which will be evaluated with the values passed as an Array.

discussion::
code::
// get the values of parameters 2, 3 an 4 and post them to console:
~fx.getn(2, 3, {arg v; v.postln;});

// get all parameter values:
~fx.getn(action: {arg v; v.postln;});
::

subsection:: Preset Management

METHOD:: numPrograms
returns:: the number of available plugin programs.

METHOD:: programs
returns:: the available programs as an Array of Strings.

METHOD:: currentProgram
returns:: the index of the currently active program.

METHOD:: setProgram
change the program by index.

METHOD:: setProgramName
change the name of the current program.

METHOD:: readProgram

METHOD:: readBank

METHOD:: writeProgram

METHOD:: writeBank
read/write program/bank files.

discussion::
The program and bank files are in a standard format which is recogized by every decent DAW or VST host. This means you can freely exchange presets between different applications.

emphasis::path:: must be an absolute file path.
The file extension is arbitrary but it is good practice to use emphasis::.fxp:: for program files and emphasis::.fxb:: for bank files.

METHOD:: setProgramData

METHOD:: setBankData

set the current program/bank state as an link::Classes/Int8Array::.

METHOD:: getProgramData

METHOD:: getBankData
get the current program/bank state as an link::Classes/Int8Array::.

ARGUMENT:: action
will be called with the data as the first argument.

discussion::
The data obtained with code::getProgramData:: and code::getBankData:: is in a non-human-readable binary format which is the same as in emphasis::.fxp:: and emphasis::.fxb:: files.

note::Some plugins have additional state beyond their parameter values, so you have to use the program and bank methods above to fully save/restore them. 
For simple plugins it's probably sufficient to just use link::#-getn:: and link::#-setn:: to save and recall parameter values.
::

subsection:: MIDI

METHOD:: midiInput
returns:: whether the plugin receives MIDI messages.

METHOD:: midiOutput
returns:: whether the plugin sends MIDI messages.

METHOD:: midiNoteOn
send a MIDI note on message.

METHOD:: midiNoteOff
send a MIDI note off message.

METHOD:: midiControl
send a MIDI CC message.

METHOD:: midiBend
send a MIDI pitch bend message. code::val:: must be in the range 0 - 16383.

METHOD:: midiPolyTouch
send a polyphonic aftertouch message.

METHOD:: midiTouch
send a MIDI channel aftertouch message.

METHOD:: midiProgram
send a MIDI program change message.

METHOD:: midiMsg
send a raw MIDI message with 2-3 bytes (status, data1, data2).

METHOD:: midiSysex
send a system exclusive message as an link::Classes/Int8Array::.

subsection:: Transport

METHOD:: setPlaying
set the transport playing state to true or false. Only necessary for VST plugins which do some kind of sequencing.

METHOD:: setTempo
set the tempo in BPM (beats per minute).

METHOD:: setTimeSignature
set the time signature, e.g. 3/4 -> num = 3, denom = 4.

METHOD:: setTransportPos
set the current transport position (in quarter notes).

METHOD:: getTransportPos
get the current transport position (in quarter notes).

ARGUMENT:: action
a function which is called with the transport position.

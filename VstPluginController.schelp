TITLE:: VstPluginController
summary:: control a VST plugin
categories:: Utility
related:: Classes/VstPlugin

DESCRIPTION::

This class is used to control a specific link::Classes/VstPlugin:: instance in a link::Classes/Synth::, so you can
link::#-open:: plugins, show the GUI, change programs, send link::#MIDI:: messages, etc.

warning::Please read the sections about link::#Realtime-Safety:: and link::#Other Caveats:: ::

Here's a quick example showing a simple insert effect on a 2-channel audio bus:

code::
SynthDef(\insert, { arg bus;
    ReplaceOut.ar(bus, VstPlugin.ar(In.ar(bus, 2), 2));  
}).add;

// create the synth:
~synth = Synth(\insert, [\bus, ~bus]);
// get a handle to the VstPlugin:
~fx = VstPluginController(~synth);
// open a plugin:
~fx.open("/path/to/plugin", info: true);
// show the GUI:
~fx.showGui;
// etc.
::

If you have more than one instance of VstPlugin in your SynthDef, you need to give them unique IDs so that VstPluginController can find the right instance:

code::
// two VST plugins in series:
SynthDef(\insert2, { arg bus;
    var sig;
	sig = In.ar(bus, 2);
    sig = VstPlugin.ar(sig, 2, id: \eq);
    sig = VstPlugin.ar(sig, 2, id: \chorus);
    ReplaceOut.ar(bus, );  
}).add;

// create the synth:
~synth = Synth(\insert2, [\bus, ~bus]);
// get handles to the VstPlugins:
~eq = VstPluginController(~synth, \eq);
~chorus = VstPluginController(~synth, \chorus);
// etc.
::

subsection:: Parameter Automation and Preset Management

It is possible to automate plugin parameters with UGens or Synth controls via the code::params:: argument in link::Classes/VstPlugin#*ar::.

Additionally, you can set parameters directly with link::#-set:: and link::#-setn:: or map them to control busses with link::#-map:::

code::
// set parameter 3 to value 0.5:
~fx.set(3, 0.5);
// set 3 parameters starting from index, 1:
~fx.setn(1, [0.1, 0.2, 0.3]);

// map a parameter to a control bus:
~ctl = Bus.control(s, 1);
~fx.map(1, ~ctl);
~ctl.set(0.7);
::

Use link::#-get:: and link::#-getn:: to obtain current parameter values:
code::
// get the current value of parameter 3 and post it to the console:
~fx.get(3, {arg f; f.postln;});
::

Change programs with link::#-setProgram:::

code::
// check for available programs:
~fx.programs.postln;
// switch to program 4:
~fx.setProgram(4);
::

You can read/write preset files to save/recall VST programs and banks:
code::
// write current plugin state to a preset file.
~fx.writeProgram("/preset/file/path/test.fxp");

// ... mess around with the plugin ...
~fx.showGui;

// restore previous state:
~fx.readProgram("/preset/file/path/text.fxp");
::

It's also possible to get/set the raw plugin state as an link::Classes/Int8Array:::
code::
// get plugin state as Int8Array:
~fx.getProgramData({ arg data; d = data;});

// ... mess around with the plugin ...
~fx.showGui;

// restore previous state:
~fx.setProgramData(d);
::

subsection:: GUI

The code::gui:: argument to the link::#-open:: method specifies the type of GUI to instantiate: 

code::
f.open("/path/to/plugin", gui: \vst);
::

The default value code::\sc:: creates a generic Qt GUI in the Language which communicates with the Server via OSC messages.

On Windows and Linux you can choose code::\vst:: instead to get a native window on the server containing the 'real' VST plugin editor.
note:: Unfortunately, this is not possible (yet?) on macOS for technical reasons.::

Use code::\none:: if you don't need any GUI to save some ressources.

subsection:: Realtime-Safety

The following operations are not realtime-safe (yet):
list::
## opening/closing a plugin
## reading/writing program/bank files
::
and to a lesser extend:
list::
## setting/getting program/bank data
## sending/receiving sysex data
::

For now you are adviced to open your plugins in advance to avoid possible audio dropouts.

subsection:: Other Caveats

Whenever you open a VST plugin, the Server sends all relevant information (e.g. parameter and program names) as OSC messages to the VstPluginController instance.

In case of plugins with emphasis::lots:: of parameters or when loading many plugins at once you might experience dropped OSC messages when using UDP.
You can try to add some delay between loading plugins or switch to TCP to mitigate this problem.

CLASSMETHODS::

METHOD:: new
Create a new VstPluginController.

ARGUMENT:: synth
the link::Classes/Synth:: containing the link::Classes/VstPlugin:: you want to control.

ARGUMENT:: id
a symbol or number which uniquely identifies the link::Classes/VstPlugin:: within the link::Classes/SynthDef::.
If this is code::nil::, VstPluginController will take the first instance it can find. This means you don't need an emphasis::id:: if there's only one VstPlugin in the SynthDef.

ARGUMENT:: synthDef
the synth's link::Classes/SynthDef::. This is only needed if the SynthDef hasn't been added to the global link::Classes/SynthDescLib::, e.g. with link::Classes/SynthDef#-add::.
Otherwise it can be automatically deduced from the emphasis::synth:: argument.

PRIVATE:: msg2string

INSTANCEMETHODS::

PRIVATE:: prFree, prClear, init, sendMsg, prClearGui, prMidiMsg, prNotify

METHOD:: open
open a VST plugin.

ARGUMENT:: path
path to the plugin (with or without extension).

ARGUMENT:: onSuccess
a function to be called if the plugin could be loaded successfully.

ARGUMENT:: onFail
a function to be called if the plugin could not be loaded.

ARGUMENT:: gui
the type of GUI to use.
definitionlist::
## \sc || (the default) create a generic Qt GUI in the Language.
## \vst || create a native window with the original VST editor on the Server. note::This doesn't work (yet) on macOS!::
## \none || use no GUI at all.
::

ARGUMENT:: info
print plugin info to the console after being loaded successfully.

METHOD:: close
close the current plugin (but don't free the Synth!). You can open another plugin later.

METHOD:: reset
reset the plugin. (E.g. this might clear the delay lines in a reverb plugin.)

METHOD:: showGui
shows/hides the GUI window.

METHOD:: synth
returns:: the link::Classes/Synth:: of the currently controlled link::Classes/VstPlugin:: instance.

METHOD:: synthIndex
returns:: the index of the link::Classes/VstPlugin:: instance within the link::Classes/Synth::.

subsection:: Plugin Info

METHOD:: info
print plugin info to the console.

METHOD:: loaded
returns:: whether a plugin is currently loaded.

METHOD:: name
returns:: the name of the plugin.

METHOD:: version
returns:: the plugin version.

METHOD:: numInputs
returns:: the number of input channels (doesn't have to match the actual number of inputs of VstPlugin).

METHOD:: numOutputs
returns:: the number of output channels (doesn't have to match the actual number of outputs of VstPlugin).

METHOD:: hasEditor
returns:: whether the plugin has an editor.

METHOD:: singlePrecision
returns:: whether the plugin supports single precision.

METHOD:: doublePrecision
returns:: whether the plugin supports double precision (only for information, currently we only support single precision processing).

METHOD:: isSynth
returns:: whether the plugin is a soft synth.

subsection:: Parameters

METHOD:: numParameters
returns:: the number of parameters.

METHOD:: parameterNames
returns:: the parameter names as an Array of Strings.

METHOD:: parameterLabels
returns:: the parameter labels (units of measurement) as an Array of Strings.

METHOD:: set
Set plugin parameters.

discussion::
This method expects pairs of parameter index and value. The value(s) should be in the range 0.0 - 1.0.
code::
// set parameter 3 to value 0.9:
~fx.set(3, 0.9);
// set parameters 1 and 5:
~fx.set(1, 0.5, 5, 0.75);
::
If the parameter has been mapped to a control bus, it will be automatically unmapped.

METHOD:: setn
set sequential ranges of parameters.

discussion::
This method expects pairs of parameter index and Array of values.

code::
// this will set parameters 3, 4, 8, 9 and 10.
~fx.setn(3, [0.5, 0.75], 8, [0.1, 0.2, 0.3]);
::

METHOD:: map
map parameters to control busses.

discussion::
This methods expects pairs of parameter index and bus.
In case of multi-channel control busses the channels are mapped to a sequential range of parameters starting at the given index.
code::
~bus1 = Bus.control;
~bus2 = Bus.control(numChannels: 2);
~fx.map(3, ~bus1, 5, ~bus2);
~bus1.set(0.5); // set parameter 3
~bus2.set(0.75, 0.9); // set parameters 5 and 6.
::
note::Mapping parameters to control busses overrides any automation via UGens in the SynthDef.
::

METHOD:: unmap
Unmap parameters from a control bus.

discussion::
Pass all the parameters you want to unmap. Calling the method without arguments will unmap all parameters.
code::
// unmap parameters 4, 5, and 7
~fx.unmap(4, 5, 7);
::

METHOD:: get
get the current value of a plugin parameter.

ARGUMENT:: index
the index of the parameter.

ARGUMENT:: action
a Function which will be evaluated with the value passed as an argument.

discussion::
code::
// get the value of parameter 4 and post it to the console:
~fx.get(4, {arg f: f.postln;});
::

METHOD:: getn
get a sequential range of parameter values.

ARGUMENT:: index
the starting index.

ARGUMENT:: count
the number of sequential parameter values. If emphasis::count:: is negative, you'll get all parameters starting from emphasis::index:: up to the last parameter.

ARGUMENT:: action
a Function which will be evaluated with the values passed as an Array.

discussion::
code::
// get the values of parameters 2, 3 an 4 and post them to console:
~fx.getn(2, 3, {arg v; v.postln;});

// get all parameter values:
~fx.getn(action: {arg v; v.postln;});
::

METHOD:: parameterAutomated
the action to be called when parameters are automated from the VST plugin GUI.

discussion::
E.g. this can be helpful if you want to know the index of a parameter you're automating.

subsection:: Preset Management

METHOD:: numPrograms
returns:: the number of available plugin programs.

METHOD:: programs
returns:: the available programs as an Array of Strings.

METHOD:: currentProgram
returns:: the index of the currently active program.

METHOD:: setProgram
change the program by index.

METHOD:: setProgramName
change the name of the current program.

METHOD:: readProgram

METHOD:: readBank

METHOD:: writeProgram

METHOD:: writeBank
read/write program/bank files.

discussion::
The program and bank files are in a standard format which is recogized by every decent DAW or VST host. This means you can freely exchange presets between different applications.

emphasis::path:: must be an absolute file path.
The file extension is arbitrary but it is good practice to use emphasis::.fxp:: for program files and emphasis::.fxb:: for bank files.

METHOD:: setProgramData

METHOD:: setBankData

set the current program/bank state as an link::Classes/Int8Array::.

METHOD:: getProgramData

METHOD:: getBankData
get the current program/bank state as an link::Classes/Int8Array::.

ARGUMENT:: action
will be called with the data as the first argument.

discussion::
The data obtained with code::getProgramData:: and code::getBankData:: is in a non-human-readable binary format which is the same as in emphasis::.fxp:: and emphasis::.fxb:: files.

note::Some plugins have additional state beyond their parameter values, so you have to use the program and bank methods above to fully save/restore them. 
For simple plugins it's probably sufficient to just use link::#-getn:: and link::#-setn:: to save and recall parameter values.
::

subsection:: MIDI

METHOD:: midiInput
returns:: whether the plugin receives MIDI messages.

METHOD:: midiOutput
returns:: whether the plugin sends MIDI messages.

METHOD:: midiNoteOn
send a MIDI note on message.

METHOD:: midiNoteOff
send a MIDI note off message.

METHOD:: midiControl
send a MIDI CC message.

METHOD:: midiBend
send a MIDI pitch bend message. code::val:: must be in the range 0 - 16383.

METHOD:: midiPolyTouch
send a polyphonic aftertouch message.

METHOD:: midiTouch
send a MIDI channel aftertouch message.

METHOD:: midiProgram
send a MIDI program change message.

METHOD:: midiMsg
send a raw MIDI message with 2-3 bytes (status, data1, data2).

METHOD:: midiSysex
send a system exclusive message as an link::Classes/Int8Array::.

METHOD:: midiReceived
the action to be called for MIDI messages sent by the plugin.

discussion::
The 3 bytes of the MIDI message are passed as invidual arguments:
code::
~fx.midiReceived = {arg ...msg; "got MIDI message %".format(msg)};
::

METHOD:: sysexReceived
the action to be called for SysEx messages sent by the plugin.

discussion::
The SysEx data is passed to the action as an link::Classes/Int8Array::.

subsection:: Transport

METHOD:: setPlaying
set the transport playing state to true or false. Only necessary for VST plugins which do some kind of sequencing.

METHOD:: setTempo
set the tempo in BPM (beats per minute).

METHOD:: setTimeSignature
set the time signature, e.g. 3/4 -> num = 3, denom = 4.

METHOD:: setTransportPos
set the current transport position (in quarter notes).

METHOD:: getTransportPos
get the current transport position (in quarter notes).

ARGUMENT:: action
will be called with current transport position.

subsection:: Advanced

METHOD:: canDo

query the plugin for special capabilities.

ARGUMENT:: what
a string describing the capability. Some of these are documented in the VST SDK, but others are not.

ARGUMENT:: action
will be called with an Integer result.
table::
## 1 || yes
## -1 || no
## 0 || don't know
::

METHOD:: vendorMethod
access special functionality of a plugin which is not available via the standard parameter interface.
Generally, you have to know what you're doing, check the documentation of the plugin to see what data it expects

ARGUMENT:: index
an Integer.
ARGUMENT:: value
an Integer.
ARGUMENT:: ptr
some arbitrary data as an link::Classes/Int8Array::.
ARGUMENT:: opt
a Float.

ARGUMENT:: action
will be called with an Integer result. The meaning depends on the VST plugin.

EXAMPLES::

Build a serial FX chain:
code::
(
// a simple insert FX:
SynthDef.new(\insert, {arg bus, bypass=0;
	ReplaceOut.ar(bus, VstPlugin.ar(In.ar(bus, 2), 2, bypass));
}).add;

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

c = Bus.audio(s, 2);

// send test signal to audio bus 'c'
d = SynthDef(\input, {| out = 0, bufnum = 0 |
    Out.ar(out,
        PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), loop: 1).dup * 0.5
    )
}).play(s, [\out, c, \bufnum, b]);

// send audio bus 'c' to output
e = SynthDef(\output, {| in = 0, out = 0 |
	Out.ar(out, In.ar(in, 2))
}).play(d, [\in, c, \out, 0], addAction: \addAfter);

)

// add an insert FX to audio bus 'c':
f = VstPluginController(Synth(\insert, [\bus, c], d, addAction: \addAfter));
// load a plugin:
f.open("/path/to/plugin", info: true);
f.showGui;
f.synth.set(\bypass, 1); // bypass FX
f.synth.free; // remove from FX chain

// add another insert FX (after 'f'):
g = VstPluginController(Synth(\insert, [\bus, c], f.synth, addAction: \addAfter));
// load a plugin:
g.open("/path/to/plugin", info: true);
g.showGui;
g.synth.set(\bypass, 1); // bypass FX
g.synth.free; // remove from FX chain

// change the FX order dynamically, e.g. move 'g' before 'f':
g.synth.moveBefore(f.synth);
::
You can also create fixed FX chains by using several VstPlugins inside a SynthDef:
code::
(
// an insert FX with two plugins in series:
SynthDef.new(\insert2, {arg bus, bypass1=0, bypass2=0;
	var sig = In.ar(bus, 2);
	sig = VstPlugin.ar(sig, 2, bypass1, id: \fx1);
	sig = VstPlugin.ar(sig, 2, bypass2, id: \fx2);
	ReplaceOut.ar(bus, sig);
}).add;
)

(
~synth = Synth(\insert2, [\bus, c], d, addAction: \addAfter);
// get handles to the individual VST plugins:
~fx1 = VstPluginController(~synth, \fx1);
~fx2 = VstPluginController(~synth, \fx2);
)

// load plugins
~fx1.open("/path/to/plugin", info: true);
~fx2.open("/path/to/plugin", info: true);

~fx1.showGui;
~fx2.showGui;

// bypass FX
~synth.set(\bypass1, 1);
~synth.set(\bypass2, 1);

~synth.free; // remove FX
::
Automate parameters via control busses:
code::
~ctl = Bus.control;
~lfo = {Out.kr(~ctl, SinOsc.kr(0.25, 0, 0.5, 0.5))}.play;
// modulate the first parameter of ~fx1 by mapping it to ~ctl:
~fx1.map(0, ~ctl);
// unmap it
~fx1.unmap(0);
::
Automate parameters inside the SynthDef:
code::
(
SynthDef.new(\insert3, {arg bus, rate=0.25, bypass=0;
	var lfo, sig;
	lfo = SinOsc.kr(rate, 0, 0.5, 0.5);
	// parameter 0 will be modulated by a SinOsc
	sig = VstPlugin.ar(In.ar(bus, 2), 2, params: [0, lfo]);
	Out.ar(bus, sig);
}).add;
)

~fx3 = VstPluginController(Synth.new(\insert3, [\bus, c], d, addAction: \addAfter));

~fx3.open("/path/to/plugin", info: true);

~fx3.synth.set(\rate, 0.9); // change modulation rate
~fx3.synth.set(\bypass, 1); // bypass
~fx3.synth.free; // release FX
::
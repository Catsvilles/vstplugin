TITLE:: VstPluginGui
summary:: a generic Qt GUI for VstPluginController
categories:: GUI
related:: Classes/VstPlugin, Classes/VstPluginController

DESCRIPTION::
This class is the default Qt GUI class for link::Classes/VstPluginController::, see link::Classes/VstPluginController#-gui::.

For each parameter, the GUI shows the parameter name, a slider, a text display and the parameter label (e.g. "dB").

You can automate parameters by moving the slider or entering text into the text display (not supported by all plugins).

note::Automating parameters from the Qt GUI will automatically unmap it from any control busses (see link::Classes/VstPluginController#-map::)::

note::For performance reasons, the Qt GUI will emphasis::not:: not reflect parameter automation via link::Classes/VstPluginController#-map:: or UGen arguments
(i.e. the code::params:: argument for link::Classes/VstPlugin#*ar::).::

By pressing the "Open" button you will get a Dialog where you can browse already loaded plugins, make a new search in the default directories
(see link::Classes/VstPlugin#*search::) or open a file dialog.

The GUI also features a PopUpMenu with available programs and panels to read/write program and bank files.

CLASSMETHODS::

Global defaults for GUI properties, see link::#Customization::.

INSTANCEMETHODS::

PRIVATE:: guify, prFree, prParam, prProgram, prProgramIndex, prUpdateGui, prOpen, writeName

METHOD:: gui
Initialize the GUI.

ARGUMENT:: parent
If parent is code::nil::, the GUI will be displayed in a new top level link::Classes/Window::, otherwise it is embedded
in the given parent (see link::#Embedding::).

ARGUMENT:: bounds
If parent is code::nil::, this will set the window geometry, otherwise it
determines the size and position of the embedded GUI.

DISCUSSION::
Usually, this is called indirectly by link::Classes/VstPluginController#-gui::.

Occasionally you might want to call it directly, e.g. to create an initially empty view where you can
set the link::#-model:: later.

METHOD:: model
the model (a link::Classes/VstPluginController:: instance).

DISCUSSION::
VstPluginGui receives notifications for relevant changes in the model, e.g. when a new plugin has been loaded or a parameter has changed.

You can always set another model and the view will update automatically (see link::#Changing Models::).

SUBSECTION:: Customization

The following instance methods allow you to customize the appearance and behavior of link::Classes/VstPluginGui::.
You can also customize globally by setting the class methods of the same name. Instance members override class members.

METHOD:: closeOnFree
whether the GUI window should be closed when the link::Classes/VstPlugin:: is freed (default: code::true::).
DISCUSSION::
This is only for top level windows, embedded GUIs are not affected.

METHOD:: displayWidth
the parameter display width in pixels (default: 60)
DISCUSSION::
The default size should be fine for most number displays but might need to be increased for larger text displays.

METHOD:: menu
whether a program menu should be created (default: code::true::)

METHOD:: numRows
the maximal number of rows (default: 10).

METHOD:: sliderWidth
the slider width in pixels (default: 200)
DISCUSSION::
the slider width also determines the width of each parameter section.
You might want to increase it if parameter names are too long to fit into a single line.

METHOD:: sliderHeight
the slider height in pixels (default: 20)



METHOD:: update
Update the view.
DISCUSSION::
This method is usually called by the model to notify the view for important changes (see link::Classes/Object#-update::).
However, it can also be called by the user (with no arguments) to update the view, e.g. after changing GUI properties:
code::
// here it's not necessary to call update because the GUI is customized *before* the 'gui' method is called
~gui = VstPluginGui.new(~model).sliderWidth_(250).gui;
// otherwise you need to call 'update' to see the effect of your customization
~gui.sliderWidth_(300).displayWidth_(80).update;
// also here
~fx.gui.sliderWidth_(500).update;
::

EXAMPLES::
Prolog:
code::
(
// a simple insert FX:
SynthDef.new(\insert, {arg bus = 0;
	ReplaceOut.ar(bus, VstPlugin.ar(In.ar(bus, 2), 2));
}).add;
)
(
// create 2 VstPlugins
~fx1 = VstPluginController(Synth(\insert));
~fx2 = VstPluginController(Synth(\insert));
)
::

SUBSECTION:: Embedding
It's possible to embed several VstPluginGui instances within a single view. 

The emphasis::bounds:: argument determines the size and position of each subview. 
(In link::Classes/FlowLayout::s the position is managed automatically,
so it's enough provide a link::Classes/Point:: instead of a link::Classes/Rect::.)

If the plugin editor needs more space than emphasis::bounds::, scrollbars are shown automatically.

code::
(
// create a Window large enough to hold two VstPluginGuis per row (see below).
~view = Window.new(bounds: 850@450, scroll: true);
~view.view.decorator = FlowLayout(w.view.bounds);
~view.front;
)
// create 2 subviews next to each other:
~fx1.gui(~view, 400@400);
~fx2.gui(~view, 400@400);
// the next GUI would go to a new row...
::

SUBSECTION:: Changing Models
Here we use a single VstPluginGui instance to show different link::Classes/VstPluginController::s.
Say you have an FX chain with several link::Classes/VstPlugin:: instances but you only need to see one at the time.

code::
// make an empty GUI
~gui = VstPluginGui.new.gui;
// show fx1
~gui.model_(~fx1);
// show fx2
~gui.model_(~fx2);
::
We could even build a link::Classes/PopUpMenu:: to change between link::Classes/VstPluginController:: instances.
